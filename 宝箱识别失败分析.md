# 宝箱识别失败分析：MuMu-20251101-124850-862.png

## 问题描述
截图 `MuMu-20251101-124850-862.png` 中没有找到宝箱，需要进行诊断分析。

## 检查流程

### 1. CheckIf 函数匹配逻辑

根据 `src/script.py` 中的 `CheckIf` 函数（第508-541行）：

```508:541:src/script.py
def CheckIf(screenImage, shortPathOfTarget, roi = None, outputMatchResult = False):
    template = LoadTemplateImage(shortPathOfTarget)
    screenshot = screenImage
    threshold = 0.80
    pos = None
    search_area = CutRoI(screenshot, roi)
    try:
        result = cv2.matchTemplate(search_area, template, cv2.TM_CCOEFF_NORMED)
    except Exception as e:
            logger.error(f"{e}")
            logger.info(f"{e}")
            if isinstance(e, (cv2.error)):
                logger.info(f"cv2异常.")
                return None

    _, max_val, _, max_loc = cv2.minMaxLoc(result)

    if outputMatchResult:
        cv2.imwrite("origin.png", screenshot)
        cv2.rectangle(screenshot, max_loc, (max_loc[0] + template.shape[1], max_loc[1] + template.shape[0]), (0, 255, 0), 2)
        cv2.imwrite("matched.png", screenshot)

    logger.debug(f"搜索到疑似{shortPathOfTarget}, 匹配程度:{max_val*100:.2f}%")
    if max_val < threshold:
        logger.debug("匹配程度不足阈值.")
        return None
    if max_val<=0.9:
        logger.debug(f"警告: {shortPathOfTarget}的匹配程度超过了{threshold*100:.0f}%但不足90%")

    pos=[max_loc[0] + template.shape[1]//2, max_loc[1] + template.shape[0]//2]
    return pos
```

**关键参数：**
- **阈值**: 80%（`threshold = 0.80`）
- **匹配方法**: `cv2.TM_CCOEFF_NORMED`
- **模板**: `resources/images/chest.png`

### 2. ROI 区域处理

对于 `target == 'chest'`，ROI会被设置为：

```152:155:src/script.py
if self.target == 'chest':
    if value == None:
        value = [[0,0,900,1600]]
    value += [[0,0,900,208],[0,1265,900,335],[0,636,137,222],[763,636,137,222], [336,208,228,77],[336,1168,228,97]]
```

**ROI说明：**
- 第一个矩形 `[0,0,900,1600]`: 搜索区域（全屏）
- 后续矩形：排除UI区域
  - `[0,0,900,208]`: 顶部UI
  - `[0,1265,900,335]`: 底部UI
  - `[0,636,137,222]`: 左侧UI
  - `[763,636,137,222]`: 右侧UI
  - `[336,208,228,77]`: 顶部中间UI
  - `[336,1168,228,97]`: 底部中间UI

### 3. CutRoI 函数逻辑

```347:385:src/script.py
def CutRoI(screenshot,roi):
    if roi is None:
        return screenshot

    img_height, img_width = screenshot.shape[:2]
    roi_copy = roi.copy()
    roi1_rect = roi_copy.pop(0)  # 第一个矩形 (x, y, width, height)

    x1, y1, w1, h1 = roi1_rect

    roi1_y_start_clipped = max(0, y1)
    roi1_y_end_clipped = min(img_height, y1 + h1)
    roi1_x_start_clipped = max(0, x1)
    roi1_x_end_clipped = min(img_width, x1 + w1)

    pixels_not_in_roi1_mask = np.ones((img_height, img_width), dtype=bool)
    if roi1_x_start_clipped < roi1_x_end_clipped and roi1_y_start_clipped < roi1_y_end_clipped:
        pixels_not_in_roi1_mask[roi1_y_start_clipped:roi1_y_end_clipped, roi1_x_start_clipped:roi1_x_end_clipped] = False

    screenshot[pixels_not_in_roi1_mask] = 0

    if (roi is not []):
        for roi2_rect in roi_copy:
            x2, y2, w2, h2 = roi2_rect

            roi2_y_start_clipped = max(0, y2)
            roi2_y_end_clipped = min(img_height, y2 + h2)
            roi2_x_start_clipped = max(0, x2)
            roi2_x_end_clipped = min(img_width, x2 + w2)

            if roi2_x_start_clipped < roi2_x_end_clipped and roi2_y_start_clipped < roi2_y_end_clipped:
                pixels_in_roi2_mask_for_current_op = np.zeros((img_height, img_width), dtype=bool)
                pixels_in_roi2_mask_for_current_op[roi2_y_start_clipped:roi2_y_end_clipped, roi2_x_start_clipped:roi2_x_end_clipped] = True

                # 将位于 roi2 中的像素设置为0
                # (如果这些像素之前因为不在roi1中已经被设为0，则此操作无额外效果)
                screenshot[pixels_in_roi2_mask_for_current_op] = 0

    # cv2.imwrite(f'CutRoI_{time.time()}.png', screenshot)
    return screenshot
```

**处理逻辑：**
1. 第一个矩形定义**搜索区域**，不在这个区域的像素被设为黑色
2. 后续矩形定义**排除区域**，在这些区域的像素也被设为黑色
3. 最终返回处理后的图像，用于模板匹配

## 可能的原因分析

### 原因1：截图尺寸不正确

**检查项：**
- 截图尺寸应该是 `900 x 1600`（宽度 x 高度）
- 如果尺寸不对，ROI区域计算会出错

**验证方法：**
```python
import cv2
img = cv2.imread("resources/quest/MuMu-20251101-124850-862.png")
print(f"截图尺寸: {img.shape}")  # 应该是 (1600, 900, 3)
```

### 原因2：宝箱被ROI排除区域遮挡

**检查项：**
- 如果宝箱位置刚好在排除的UI区域内，会被设为黑色
- 需要确认宝箱的实际位置是否在以下区域：
  - 顶部 0-208 像素
  - 底部 1265-1600 像素
  - 左侧 0-137 像素，y: 636-858
  - 右侧 763-900 像素，y: 636-858
  - 顶部中间 x: 336-564, y: 208-285
  - 底部中间 x: 336-564, y: 1168-1265

### 原因3：模板匹配度不足80%

**可能原因：**
- 宝箱图像与模板 `chest.png` 差异较大
- 光照、角度、缩放等因素影响
- 宝箱类型不同（普通宝箱 vs 石质宝箱 `chestStone.png` vs 恐惧宝箱 `chestfear.png`）

**验证方法：**
- 检查实际匹配度分数（查看日志输出）
- 尝试降低阈值到 70% 或 75% 测试

### 原因4：宝箱不在搜索区域内

**检查项：**
- 第一个ROI `[0,0,900,1600]` 定义了搜索区域
- 如果截图尺寸小于 900x1600，搜索区域会被裁剪

## 诊断步骤

### 步骤1：检查截图尺寸

运行以下代码确认截图尺寸：

```python
import cv2
import numpy as np

screenshot_path = "resources/quest/MuMu-20251101-124850-862.png"
img = cv2.imdecode(np.fromfile(screenshot_path, dtype=np.uint8), cv2.IMREAD_COLOR)
print(f"截图尺寸: {img.shape}")
print(f"宽度: {img.shape[1]}, 高度: {img.shape[0]}")
```

### 步骤2：可视化ROI处理结果

修改 `CutRoI` 函数，取消注释保存图像的代码：

```python
# 在 CutRoI 函数的 return 之前添加：
cv2.imwrite(f'CutRoI_debug.png', screenshot)
```

或者手动运行：

```python
import cv2
import numpy as np

def cut_roi_debug(screenshot, roi):
    # ... 复制 CutRoI 逻辑 ...
    cv2.imwrite('roi_processed.png', screenshot)
    return screenshot

# 使用
screenshot = cv2.imread("resources/quest/MuMu-20251101-124850-862.png")
roi = [[0,0,900,1600], [0,0,900,208], [0,1265,900,335], [0,636,137,222], [763,636,137,222], [336,208,228,77], [336,1168,228,97]]
processed = cut_roi_debug(screenshot, roi)
```

### 步骤3：测试不同阈值

临时修改 `CheckIf` 函数，测试不同阈值：

```python
# 在 CheckIf 函数中
for threshold in [0.70, 0.75, 0.80, 0.85]:
    if max_val >= threshold:
        print(f"阈值 {threshold*100:.0f}%: 找到，匹配度 {max_val*100:.2f}%")
        break
```

### 步骤4：检查宝箱类型

确认截图中的宝箱类型，可能需要使用不同的模板：
- `chest.png` - 普通宝箱
- `chestStone.png` - 石质宝箱
- `chestfear.png` - 恐惧宝箱
- `chestFlag.png` - 宝箱标记

### 步骤5：测试不使用ROI

临时禁用ROI，进行全屏搜索：

```python
# 在 StateMap_FindSwipeClick 中临时修改
targetPos = CheckIf(scn, target, roi=None)  # 不使用ROI
```

## 快速诊断脚本

创建一个诊断脚本 `diagnose_chest.py`：

```python
import cv2
import numpy as np
import sys
import os

sys.path.insert(0, 'src')

# 需要确保环境中有 cv2
try:
    from utils import LoadImage, ResourcePath, LoadTemplateImage
except ImportError:
    print("错误：无法导入 utils 模块")
    sys.exit(1)

screenshot_path = ResourcePath("resources/quest/MuMu-20251101-124850-862.png")
template_path = ResourcePath("resources/images/chest.png")

# 加载图像
screenshot = LoadImage(screenshot_path)
template = LoadTemplateImage("chest")

if screenshot is None or template is None:
    print("无法加载图像")
    sys.exit(1)

print(f"截图尺寸: {screenshot.shape}")
print(f"模板尺寸: {template.shape}")

# 测试匹配（不使用ROI）
result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)
_, max_val, _, max_loc = cv2.minMaxLoc(result)

print(f"\n全屏匹配度: {max_val*100:.2f}%")
print(f"最佳匹配位置: {max_loc}")

if max_val >= 0.80:
    print("✓ 全屏搜索找到宝箱！")
    # 标记位置
    marked = screenshot.copy()
    cv2.rectangle(marked, max_loc, 
                 (max_loc[0] + template.shape[1], max_loc[1] + template.shape[0]),
                 (0, 255, 0), 3)
    cv2.imwrite("diagnosis_result.png", marked)
    print("已保存标记结果到: diagnosis_result.png")
else:
    print(f"✗ 全屏搜索未找到（匹配度 {max_val*100:.2f}% < 80%）")
```

## 建议的修复方案

1. **如果是尺寸问题**：确保截图尺寸为 900x1600
2. **如果是ROI问题**：检查宝箱是否在排除区域内，如果是，需要调整ROI配置
3. **如果是阈值问题**：
   - 检查实际匹配度分数
   - 如果接近80%（如75-79%），可以考虑降低阈值
   - 或者在特定地图使用更低的阈值
4. **如果是模板问题**：确认宝箱类型，使用正确的模板

## 调试输出

在 `CheckIf` 函数中，可以添加更详细的日志输出：

```python
logger.debug(f"搜索到疑似{shortPathOfTarget}, 匹配程度:{max_val*100:.2f}%")
logger.debug(f"最佳匹配位置: {max_loc}")
logger.debug(f"模板尺寸: {template.shape}, 截图尺寸: {screenImage.shape}")
if max_val < threshold:
    logger.warning(f"匹配度 {max_val*100:.2f}% 不足阈值 {threshold*100:.0f}%")
```

启用 `outputMatchResult=True` 可以保存匹配结果图像：

```python
targetPos = CheckIf(scn, target, roi, outputMatchResult=True)
# 会生成 origin.png 和 matched.png
```

