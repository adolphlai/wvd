# 停止信號機制說明

## 概述

本專案使用 `_FORCESTOPING` 事件標誌來控制腳本的停止行為。為了確保程式能快速響應停止請求，我們實現了一套基於異常的統一停止信號機制。

---

## 停止信號機制對比

### 機制對照表

| 項目 | 舊模式 | 新模式 |
|------|--------|--------|
| **檢查方式** | `if setting._FORCESTOPING.is_set(): return` | `check_stop_signal()` |
| **退出方式** | 條件判斷後 return | 拋出 `StopSignalException` 異常 |
| **響應速度** | 需等待執行到檢查點 | 立即中斷並向上冒泡 |
| **適用場景** | 初始化函數、監控線程 | 所有業務邏輯循環 |

### 舊模式說明

**語法：**
```python
while True:
    if setting._FORCESTOPING and setting._FORCESTOPING.is_set():
        return None
    # ... 業務邏輯 ...
```

**特性：**
- 需要代碼執行到 `if` 判斷才會檢查停止信號
- 如果循環體內有耗時操作（如 `Sleep()`、`ScreenShot()`），響應會延遲
- 適用於 Factory 函數外部的初始化代碼（如 `CheckRestartConnectADB`）

**問題：**
- 當循環體較長時，停止信號響應慢
- 可能導致「停止程式失去回應」的現象

---

### 新模式說明（推薦）

**語法：**
```python
@stoppable
def SomeFunction():
    while True:
        check_stop_signal()  # 每次迭代開始時檢查
        # ... 業務邏輯 ...
```

**特性：**
- `check_stop_signal()` 會立即檢查信號，若已設置則拋出 `StopSignalException`
- 異常會自動向上冒泡，被上層的 try-except 捕獲
- `@stoppable` 裝飾器會在函數入口自動檢查一次

**優點：**
- 響應快速，幾乎立即中斷
- 統一的錯誤處理機制
- 代碼更簡潔

---

## 核心實現

### StopSignalException 異常類

```python
class StopSignalException(Exception):
    """用戶請求停止時拋出的異常，會自動向上冒泡到主循環"""
    pass
```

### check_stop_signal() 函數

```python
def check_stop_signal():
    """檢查停止信號，若已設置則拋出 StopSignalException"""
    if setting._FORCESTOPING and setting._FORCESTOPING.is_set():
        raise StopSignalException()
```

### @stoppable 裝飾器

```python
def stoppable(func):
    """裝飾器：每次進入函數時自動檢查停止信號"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        check_stop_signal()
        return func(*args, **kwargs)
    return wrapper
```

---

## 使用規範

### 1. 函數裝飾器

所有包含循環或長時間執行的函數，應使用 `@stoppable` 裝飾器：

```python
@stoppable
def StateCombat():
    # 函數入口自動檢查停止信號
    ...
```

### 2. 循環內檢查

所有 `while` 循環開頭應調用 `check_stop_signal()`：

```python
while True:
    check_stop_signal()  # 每次迭代開始時檢查
    ...
```

### 3. 長時間 for 循環

如果 `for` 循環可能執行較長時間，也應添加檢查：

```python
for i in range(30):
    check_stop_signal()  # 確保能快速響應停止信號
    ...
```

### 4. 異常處理

上層函數應正確捕獲 `StopSignalException`：

```python
try:
    # 業務邏輯
except StopSignalException:
    logger.info("收到停止信號，優雅退出")
    return
```

---

## 適用場景對照

| 場景 | 建議模式 | 說明 |
|------|----------|------|
| Factory 內的業務循環 | **新模式** | 使用 `check_stop_signal()` |
| 狀態機主循環 (StateDungeon, StateCombat 等) | **新模式** | 使用 `@stoppable` + `check_stop_signal()` |
| 初始化函數 (CheckRestartConnectADB 等) | 舊模式 | 在 Factory 外部，無法使用統一機制 |
| 監控線程 (GameMonitor 等) | 舊模式 | 獨立線程，需要自行處理 |
| Sleep 替代函數內部 | 舊模式 | 已在 Sleep() 內部實現 |

---

## 修復記錄 (2026-01-17)

### 問題描述

用戶報告「停止程式失去回應」，點擊停止按鈕後程式無法快速退出。

### 根本原因

代碼中存在兩種停止信號檢查模式的混用。當循環使用舊模式且循環體較長時，停止信號響應延遲。

### 修復位置

| 序號 | 函數 | 行號 | 循環類型 | 修復內容 |
|------|------|------|----------|----------|
| 1 | `BossCombat` | 3906 | `for wait_count in range(30)` | 添加 `check_stop_signal()` |
| 2 | `StateCombat` | 4060 | `for wait_count in range(30)` | 添加 `check_stop_signal()` |
| 3 | `StateCombat` | 4113 | `while spam_click_count < MAX` | 改用 `check_stop_signal()` |
| 4 | `StateChest` | 5457 | 主 `while True` 循環 | 改用 `check_stop_signal()` |
| 5 | `StateChest` | 5530 | 選擇開箱角色循環 | 改用 `check_stop_signal()` |
| 6 | `StateChest` | 5596 | AUTO 偵測循環 | 改用 `check_stop_signal()` |
| 7 | `QuestFarm` 7000G | 6111 | 主 `while 1` 循環 | 改用 `check_stop_signal()` |
| 8 | `QuestFarm` 7000G | 6126 | leap 偵測循環 | 改用 `check_stop_signal()` |
| 9 | `QuestFarm` fordraig | 6198 | 主 `while 1` 循環 | 改用 `check_stop_signal()` |

### 修復效果

- 停止信號設置後，程式可在 100ms 內響應
- 異常機制確保任何深層循環都能快速退出
- 保持向後兼容，不影響正常業務邏輯

---

## 注意事項

1. **禁止直接使用舊模式**：在 Factory 內部的業務邏輯中，禁止直接使用 `if setting._FORCESTOPING.is_set(): return`，必須通過統一機制處理。

2. **Sleep() 函數已優化**：`Sleep()` 函數內部已實現停止信號檢查，會自動響應停止請求。

3. **ScreenShot() 函數已優化**：`ScreenShot()` 函數入口也會檢查停止信號。

4. **裝飾器只檢查入口**：`@stoppable` 裝飾器只在函數入口檢查一次，長循環仍需在每次迭代調用 `check_stop_signal()`。

---

## 相關文件

- `src/script.py` - 主要邏輯實現
- `GEMINI.md` - 項目規範（包含停止信號機制規範）
