# 自動戰鬥模式狀態控制分析

本文件記錄自動戰鬥模式如何控制不同場景下的戰鬥狀態。

## 核心設定變數 (`FarmConfig`)

| 變數名 | 類型 | 說明 |
|--------|------|------|
| `_AUTO_COMBAT_MODE` | `StringVar` | 自動戰鬥模式：「完全自動」/「1 場後自動」/「2 場後自動」/「3 場後自動」/「完全手動」 |
| `_CHARACTER_SKILL_CONFIG` | `list` | 角色技能配置，決定每場戰鬥要施放的技能 |
| `_AE_CASTER_INTERVAL` | `IntVar` | 觸發間隔（0 = 每場觸發） |

## 運行時狀態變數 (`RuntimeContext`)

| 變數名 | 類別初始值 | 說明 |
|--------|-----------|------|
| `_COMBAT_BATTLE_COUNT` | `0` | 當前第幾戰（1=第一戰, 2=第二戰...） |
| `_COMBAT_ACTION_COUNT` | `0` | 每場戰鬥的行動次數 |
| `_AOE_TRIGGERED_THIS_DUNGEON` | `False` | 本次地城是否已觸發自動戰鬥 |
| `_AE_CASTER_FIRST_ATTACK_DONE` | `False` | AE 手是否已完成首次普攻 |
| `_RESET_BATTLE_COUNT_AFTER_RECOVER` | `False` | 麻痺/封技恢復後重置戰鬥計數器標誌 |
| `_RESTART_SKIP_INTERVAL_THIS_DUNGEON` | `False` | 重啟後跳過間隔判斷標誌，讓 `_AUTO_COMBAT_MODE` 正常運作 |
| `_MID_DUNGEON_START` | `False` | 地城內啟動標記（用於跳過黑屏打斷） |
| `_DUNGEON_CONFIRMED` | `False` | 已確認進入地城 |
| `_IS_FIRST_COMBAT_IN_DUNGEON` | `True` | 本次地城的首戰標記 |
| `_FIRST_DUNGEON_ENTRY` | `True` | 第一次進入地城標誌 |

---

## 三種主要戰鬥場景

### 場景 1：村莊中啟動腳本進入地城（正常流程）

**初始值設定位置**：`reset_ae_caster_flags()` 函數 + `State.Dungeon` case

```python
# reset_ae_caster_flags() (line ~3316)
runtimeContext._AOE_TRIGGERED_THIS_DUNGEON = False
runtimeContext._AE_CASTER_FIRST_ATTACK_DONE = False
runtimeContext._COMBAT_ACTION_COUNT = 0
runtimeContext._COMBAT_BATTLE_COUNT = 0
runtimeContext._DUNGEON_CONFIRMED = False
runtimeContext._IS_FIRST_COMBAT_IN_DUNGEON = True
runtimeContext._MID_DUNGEON_START = False
```

| 變數 | 初始值 | 說明 |
|------|--------|------|
| `_COMBAT_BATTLE_COUNT` | `0` | 進入戰鬥時 +1 |
| `_AOE_TRIGGERED_THIS_DUNGEON` | `False` | 尚未觸發自動戰鬥 |
| `_DUNGEON_CONFIRMED` | `False` → `True` | 偵測到地城後設為 True |
| `_MID_DUNGEON_START` | `False` | 允許黑屏偵測 |

---

### 場景 2：地城內啟動腳本的戰鬥

**偵測條件**：首次 `IdentifyState()` 結果是 `State.Dungeon` 且 `_COUNTERDUNG == 0`

**初始值設定位置**：line ~5391-5401

```python
if state == State.Dungeon and runtimeContext._COUNTERDUNG == 0:
    runtimeContext._FIRST_DUNGEON_ENTRY = False  # 已經在地城內
    runtimeContext._STEPAFTERRESTART = True      # 不需要防轉圈
    runtimeContext._AOE_TRIGGERED_THIS_DUNGEON = False
    runtimeContext._COMBAT_ACTION_COUNT = 0
    runtimeContext._COMBAT_BATTLE_COUNT = 0
    runtimeContext._DUNGEON_CONFIRMED = True     # 直接確認在地城
    # 不設置 _MID_DUNGEON_START = True，讓黑屏偵測正常觸發
```

| 變數 | 初始值 | 說明 |
|------|--------|------|
| `_COMBAT_BATTLE_COUNT` | `0` | 視為第一戰 |
| `_DUNGEON_CONFIRMED` | `True` | **直接確認**在地城 |
| `_FIRST_DUNGEON_ENTRY` | `False` | 已經在地城內 |
| `_STEPAFTERRESTART` | `True` | 不需要防轉圈 |
| `_MID_DUNGEON_START` | `False` | **讓黑屏偵測正常觸發** |

> **NOTE**: 代碼特意不設置 `_MID_DUNGEON_START = True`，讓黑屏偵測正常觸發。

---

### 場景 3：遊戲重啟後的戰鬥

**初始值設定位置**：`restartGame()` 函數 (line ~1904-1918)

```python
def restartGame(skipScreenShot = False):
    runtimeContext._IN_RESTART = True
    runtimeContext._COMBATSPD = False
    runtimeContext._TIME_CHEST = 0
    runtimeContext._TIME_COMBAT = 0
    runtimeContext._ZOOMWORLDMAP = False
    runtimeContext._STEPAFTERRESTART = False      # 需要執行防轉圈
    runtimeContext._RESTART_OPEN_MAP_PENDING = True
    runtimeContext._DUNGEON_CONFIRMED = False     # 重置地城確認
    runtimeContext._RESTART_PENDING_BATTLE_RESET = True  # ★ 關鍵標誌
    reset_ae_caster_flags()  # 重置所有 AE 相關旗標
    # [重要] 必須在 reset 後設置，否則旗標會被重置函數清空
    runtimeContext._RESTART_SKIP_INTERVAL_THIS_DUNGEON = True
```

| 變數 | 初始值 | 說明 |
|------|--------|------|
| `_RESTART_PENDING_BATTLE_RESET` | `True` | **關鍵標誌**：進入 StateCombat 時重置計數器 |
| `_COMBAT_BATTLE_COUNT` | `0` | via `reset_ae_caster_flags` |
| `_DUNGEON_CONFIRMED` | `False` | 需重新確認進入地城 |
| `_STEPAFTERRESTART` | `False` | **需要執行防轉圈** |
| `_RESTART_OPEN_MAP_PENDING` | `True` | 跳過 Resume，強制開地圖 |

**重啟後進入 StateCombat 時的處理**：
```python
# line ~3645-3649
if runtimeContext._RESTART_PENDING_BATTLE_RESET:
    runtimeContext._COMBAT_ACTION_COUNT = 0
    runtimeContext._COMBAT_BATTLE_COUNT = 0
    runtimeContext._RESTART_PENDING_BATTLE_RESET = False
```

---

## 其他戰鬥場景

### 連續刷地城（不回村）

當 `_DUNGEON_REPEAT_LIMIT > 0`：
- 如果不回村，`_DUNGEON_REPEAT_COUNT += 1`
- 每次進入新地城時仍調用 `reset_ae_caster_flags()` 重置戰鬥計數

### 死亡後恢復

`RiseAgainReset()` 函數重置 `_SUICIDE` 和 `_RECOVERAFTERREZ`，不影響戰鬥場數計數。

### 觸發間隔不匹配

當 `_COUNTERDUNG` 與 `_AE_CASTER_INTERVAL` 不匹配時，直接開啟自動戰鬥：
```python
if has_skill_config and not ae_interval_match:
    runtimeContext._AOE_TRIGGERED_THIS_DUNGEON = True
    enable_auto_combat()
```

---

## 核心判斷函數

```python
def should_enable_auto_combat(battle_count, auto_combat_mode):
    """判斷是否應該開啟自動戰鬥"""
    manual_battles = get_auto_combat_battles(auto_combat_mode)
    if manual_battles == -1:  # 完全手動
        return False
    return battle_count > manual_battles

def get_auto_combat_battles(auto_combat_mode):
    """根據模式返回需要手動的戰鬥場數"""
    mode_map = {
        "完全自動": 0,
        "1 場後自動": 1,
        "2 場後自動": 2,
        "3 場後自動": 3,
        "完全手動": -1
    }
    return mode_map.get(auto_combat_mode, 2)
```

---

## 黑屏打斷邏輯

黑屏打斷條件 (line ~2172)：
```python
if (runtimeContext._DUNGEON_CONFIRMED and 
    not runtimeContext._AOE_TRIGGERED_THIS_DUNGEON and 
    runtimeContext._COMBAT_ACTION_COUNT == 0 and 
    not runtimeContext._MID_DUNGEON_START and 
    is_black and 
    should_interrupt_auto):
    # 執行黑屏打斷...
```

必須同時滿足：
1. `_DUNGEON_CONFIRMED = True`（已確認在地城）
2. `_AOE_TRIGGERED_THIS_DUNGEON = False`（尚未觸發自動戰鬥）
3. `_COMBAT_ACTION_COUNT = 0`（行動計數為 0）
4. `_MID_DUNGEON_START = False`（非地城內啟動）
5. 畫面為黑屏
6. 當前場次需要手動

---

## 總結表格

| 場景 | `_COMBAT_BATTLE_COUNT` | `_AOE_TRIGGERED_THIS_DUNGEON` | `_MID_DUNGEON_START` | `_RESTART_PENDING_BATTLE_RESET` | `_DUNGEON_CONFIRMED` |
|------|------------------------|------------------------------|----------------------|--------------------------------|---------------------|
| **村莊啟動（正常）** | `0` | `False` | `False` | `False` | `False` → `True` |
| **地城內啟動** | `0` | `False` | `False` ★ | `False` | `True` |
| **遊戲重啟後** | `0` | `False` | `False` | `True` ★ | `False` |

★ = 關鍵差異點

---

## 相關代碼位置

| 函數/位置 | 說明 |
|-----------|------|
| `RuntimeContext` 類別 (line ~488-529) | 狀態變數定義 |
| `reset_ae_caster_flags()` (line ~3316) | 重置戰鬥相關旗標 |
| `restartGame()` (line ~1904) | 遊戲重啟處理 |
| `StateCombat()` (line ~3542) | 戰鬥狀態處理 |
| `IdentifyState()` (line ~2144) | 狀態識別與黑屏打斷 |
| `should_enable_auto_combat()` (line ~3379) | 自動戰鬥判斷 |

---

## 腳本啟動與重啟場景狀態對照表

| 功能特性 | 村莊啟動 (正常流程) | 地城內啟動 (中途掛機) | 當機後重啟 (自動恢復) |
| :--- | :--- | :--- | :--- |
| **技能施放設定** | 根據模式選擇 (從首戰開始) | 根據模式選擇 (從首戰開始) | 根據模式選擇 (重置為首戰) |
| **自動戰鬥** | 根據模式選擇 (依戰鬥場數) | 根據模式選擇 (依戰鬥場數) | 根據模式選擇 (重裝後的首戰) |
| **解除麻痺\|封技** | 解除後根據模式選擇 | 解除後根據模式選擇 | 解除之後根據模式選擇 |
| **防止轉圈 (平移)** | **不啟動** (預設已執行) | **不啟動** (明確跳過) | **啟動** (強制執行一次) |
| **連續戰鬥 (計數)** | **不啟動** (從 0 開始) | **不啟動** (判定為 0) | **啟動** (保持當前地城次數) |
| **黑屏打斷** | **啟動** (正常偵測) | **啟動** (代碼已開放觸發) | **啟動** (正常偵測) |
| **間隔判斷 (AE)** | 正常判斷 (根據地城次數) | 正常判斷 (根據地城次數) | **跳過** (本次地城強制手動) |

### 詳細邏輯補充說明：

1.  **技能與自動戰鬥**：這三種情況都會在進入戰鬥時將「戰鬥場數」初始化，因此都會觸發 UI 設定的「首戰技能」。
2.  **防止轉圈 (`_STEPAFTERRESTART`)**：只有在 `restartGame()` 觸發時會設為 `False` 並執行平移。
3.  **連續戰鬥 (`_COUNTERDUNG`)**：重啟時不會清空此計數器，以維持連續刷地城的邏輯。
4.  **間隔判斷 (AE)**：重啟後的當前地城會跳過間隔檢查（強制手動/依模式施放），新地城則恢復正常。
    - **注意**：在 `restartGame` 中設置該旗標時，必須在 `reset_ae_caster_flags()` 調用之後，否則會被重置函數清空。
